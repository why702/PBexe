/*
 * Copyright (c) 2008 - 2013, Precise Biometrics AB
 * All rights reserved.
 *
 */

#ifndef PB_DEFENDERI_H
#define PB_DEFENDERI_H

#include "pb_errors.h"
#include "pb_types.h"
#include "pb_session.h"
#include "pb_alignment.h"
#include "pb_finger.h"
#include "pb_reader.h"

#ifdef __cplusplus
extern "C" {
#endif

/** A latent fingerprint is a fingerprint generated from the grease
  * left by the previous finger on the sensor. Such fingerprints may
  * be generated by adding moisture to the sensor, e.g. by breathing
  * on it. Some sensors may produce latent fingerprints that are very
  * similar to the original ones, while others might not produce any 
  * latent fingerprints at all (e.g. swipe sensors).
  *
  * Latent fingerprints may pose a threat to the biometric system and
  * must therefore be detected. Since latent fingerprints may be very 
  * similar to the original fingerprint the only generic way to detect
  * them is to check if they appear on the same location as the 
  * previous true fingerprint. Thus, if the alignment between the two
  * fingerprints in a match is similar to the alignment between the 
  * two fingerprints in the previous match, it might be a latency match. 
  *
  * Note however that there is also the possibility that the user 
  * places his/her finger at the same location again in which case this 
  * function would also return latency. Thus, using this function will
  * increase the false rejection rate!
  *
  * This is an attack that may be used at an identification system, 
  * where no token is presented when matching. In a verification system
  * the user often has to present a token, identifying him/her and 
  * allowing for the system to know which stored template to verify 
  * against. Thus, it is unlikely that such an attack would be succesful
  * in a verification system since an attacker would most likely have to 
  * steal the token from the user that was previously matched in the 
  * system and then generate a latent fingerprint before another user
  * puts his/her finger on the sensor. It is recommended that the 
  * designer of the system weights the benefits of using this function 
  * against the drawbacks of the increased false rejection rate!
  *
  * Important: Call this function for each accept in the system. Do not call 
  * it for rejects!
  *
  * @param[in] session is the session object.
  * @param[in] alignment is the alignment between the two fingerprints
  *     in the current match.
  * @param[in] finger is the finger that the fingerprint was matched 
  *     against.
  * @param[in] reader is the reader that the fingerprint was captured
  *     from.
  * @param[out] is_latent tells if the fingerprint was latent (1) or 
  *     not (0).
  *
  * @return PB_RC_OK if successful, or an error code. 
  */
typedef pb_rc_t pb_defenderI_finger_is_latent_fn_t (pb_session_t* session,
                                                    const pb_alignment_t* alignment,
                                                    const pb_finger_t* finger,
                                                    pb_reader_t* reader,
                                                    int* is_latent);

/** Depending on the false accept rate used in the system, there is 
  * a certain chance that a fingerprint from an impostor is accepted.
  * By flooding the system with different impostor matches the system 
  * will eventually "break" and accept an impostor. These, so called,
  * brute force attacks may be very successful in low security systems, 
  * i.e. systems with high false accept rates. E.g. in a system with 
  * FAR 1/1000 that is capable of veryfying 2 fingerprints per second, 
  * it takes less than 10 minutes in general to receive a false accept.
  *
  * In order to prevent these attacks the system must detect when 
  * multiple rejects have been made in sequence and block that or those
  * fingers involved in the attack for a certain time, or possibly 
  * forever. 
  *
  * Call this function to notify the defender that the specified finger
  * has been rejected or accepted. The defender may then block this 
  * and/or other fingers from using the system for a certain amount of 
  * time. The functions finger_is_blocked and unblock_finger can then 
  * be used to determine if a finger is blocked and to unblock a finger, 
  * respectively. 
  *
  * @param[in] session is the session object.
  * @param[in] finger is the finger that the fingerprint was matched 
  *     against.
  * @param[in] decision is the decision of the match, accept (1)
  *     or reject (0).
  *
  * @return PB_RC_OK if successful, or an error code. 
  */
typedef pb_rc_t pb_defenderI_notify_decision_fn_t (pb_session_t* session,
                                                   const pb_finger_t* finger,
                                                   int decision);

/** Tells if the specified finger is blocked or not. In order for this 
  * function to produce accurate results, the notify_decision must have
  * been called for each verification/identification in the system.
  *
  * @param[in] session is the session object.
  * @param[in] finger is the finger to check if it is blocked or not.
  * @param[out] is_blocked tells if the finger is blocked (1) or not (0).
  *
  * @return PB_RC_OK if successful, or an error code. 
  */
typedef pb_rc_t pb_defenderI_finger_is_blocked_fn_t (pb_session_t* session,
                                                     const pb_finger_t* finger,
                                                     int* is_blocked);

/** Unblocks the specified finger. This function may be called if an
  * administrator of the system wishes to unblock a finger that has
  * been blocked by the system. Note that the block will most likely be 
  * under a time constraint, so eventually the block will be released
  * anyway. 
  *
  * @param[in] session is the session object.
  * @param[in] finger is the finger to unblock.
  *
  * @return PB_RC_OK if successful, or an error code. 
  */
typedef pb_rc_t pb_defenderI_unblock_finger_fn_t (pb_session_t* session,
                                                  const pb_finger_t* finger);

/// The defender API
typedef struct {
    /// See definition of pb_defenderI_finger_is_latent_fn_t()
    pb_defenderI_finger_is_latent_fn_t* finger_is_latent;
    /// See definition of pb_defenderI_notify_decision_fn_t()
    pb_defenderI_notify_decision_fn_t* notify_decision;
    /// See definition of pb_defenderI_finger_is_blocked_fn_t()
    pb_defenderI_finger_is_blocked_fn_t* finger_is_blocked;
    /// See definition of pb_defenderI_unblock_finger_fn_t()
    pb_defenderI_unblock_finger_fn_t* unblock_finger;
} pb_defenderI;

#ifdef __cplusplus
}
#endif

#endif /* PB_DEFENDERI_H */
